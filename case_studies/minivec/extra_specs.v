Section resolve_ghost.
  Context `{!typeGS Σ}.
  Context {T_rt : Type}.
  Context (T_ty : type (T_rt)).

  (* NOTE Resolution of ghost variables over the invariant -- not currently automatically generated by the frontend. *)
  Lemma resolve_ghost_Vec_T π E L rm l rs T :
    (∀ li, resolve_ghost_iter π E L rm false li (ty_syn_type T_ty) (replicate (length rs) (◁ T_ty))%I (Owned false) rs [] 0%nat (λ L2 rs' R progress,
      T L2 (#rs') R progress)) ⊢
    resolve_ghost π E L rm true l (◁ Vec_inv_t T_ty) (Owned false) (#rs) T.
  Proof.
  Admitted.
  Global Instance resolve_ghost_Vec_T_inst π E L rm l rs : ResolveGhost π E L rm true l (◁ Vec_inv_t T_ty)%I (Owned false) (#rs) :=
    λ T, i2p (resolve_ghost_Vec_T π E L rm l rs T).
End resolve_ghost.

Section subtype.
  Context `{!typeGS Σ}.
  (* NOTE: variance proofs are currently not automatically generated by the frontend *)
  Lemma std_option_Option_ty_weak_subtype E L {T_rt1 T_rt2} (T_ty1 : type T_rt1) (T_ty2 : type T_rt2) r1 r2 T :
    (∃ r2', ⌜ r2 = Some (#r2')⌝ ∗ weak_subtype E L r1 r2' T_ty1 T_ty2 T) ⊢
    weak_subtype E L (Some (#r1)) r2 (std_option_Option_ty T_ty1) (std_option_Option_ty T_ty2) T.
  Proof.
  Admitted.
  Global Instance std_option_Option_ty_weak_subtype_inst E L {T_rt1 T_rt2} (T_ty1 : type T_rt1) (T_ty2 : type T_rt2) r1 r2 :
  Subtype E L (Some (#r1)) r2 (std_option_Option_ty T_ty1) (std_option_Option_ty T_ty2) := λ T, i2p (std_option_Option_ty_weak_subtype E L T_ty1 T_ty2 r1 r2 T).
End subtype.

(* TODO manually added unwrap *)
Definition type_of_std_option_Option_unwrap (T_rt : Type) `{Inhabited T_rt} (T_st : syn_type) :=
  fn(∀ (()) : 0 | (x, T_ty) : (_ * (type T_rt)), (λ ϝ, []); Some (#x) @ (std_option_Option_ty (T_ty)); (λ π : thread_id, (⌜ty_syn_type T_ty = T_st⌝) ∗ (⌜ty_allows_writes T_ty⌝) ∗ (⌜ty_allows_reads T_ty⌝) ∗ (ty_sidecond T_ty)))
    → ∃ _ : unit, x @ T_ty; (λ π : thread_id, True).
